import groovy.json.JsonSlurper

// GROUPWISE AUTOMATED VERSION + PUBLISH
// Automates main- and subpackages version bumping and NPM publishing of updated packages, using lerna and some custom logic.
// Purpose: handles interdependencies between packages/* so that dependents are published first, then updates those references
// in package.json and package-lock.json on consuming packages.
//
// Versions are autogenerated, based on 'feat:' and 'BREAKING CHANGE' git commit messages (see https://www.conventionalcommits.org/en/v1.0.0/)
//
// Why? Lerna updates versions and dependents, but internal dependencies between the packages means that dependents need
// to update their package-lock AFTER their dependencies have been released with new lerna-generated versions.
//
// So [ lerna-version --> publish --> post-publish-git ] happens in 3 stages (levels), to ensure that package-locks are
// rebuilt with existing/published package versions:
//   - Level 1: The regions + constants packages are released FIRST, since other packages depend on them,
//   - Level 3: The react4xp package is released LAST, since it depends on all the other packages,
//   - Level 2: All other packages are published in between.
// Before all this, building/linting/tests are run.
// And finally, temporary (prerelease) tags created by lerna are wiped, based on project.ext.PRERELEASE_ID
//
// Usage, always from project root: gradlew versionAndPublish
// CLI options:
//   -Pmessage=... (describes the entire multi-level publication)
//   -Pdry (dry-run)
//
// Full task run sequence when calling gradlew versionAndPublish:
//    npmInstall
//    build
//    test
//    npmRebuildForProd
//                              For packages in level 1:
//    versionLevel1             (lerna version - tick versions in level1 packages and update version numbers in lavel 2/3 packages that depend on them if they were updated)
//    maybeSkipPublishLevel1
//    publishLevel1             (npm publish, if not disabled by maybeSkipPublishLevel1)
//    wait1                     (wait for user input, opportunity to verify interdependencies)
//    npmClean1                 (delete node_modules)
//    npmInstall1               (npm i - to refresh package-lock.json)
//    gitAdd1                   (git add, if not dry-run)
//    gitCommit1                (git commit, if not dry-run)
//    gitPush1                  (git push, if not dry-run)
//    postLevel1
//                              Same for packages in level 2:
//    versionLevel2
//    maybeSkipPublishLevel2
//    publishLevel2
//    wait2
//    npmClean2
//    npmInstall2
//    gitAdd2
//    gitCommit2
//    gitPush2
//    postLevel2
//                              Similar for packages in level 3 (but prerelease git tag cleanup instead of manual version verification)
//    versionLevel3
//    maybeSkipPublishLevel3
//    publishLevel3
//    cleanPrereleaseTags
//    npmClean3
//    npmInstall3
//    gitAdd3
//    gitCommit3
//    gitPush3
//    postLevel3
//
//    versionAndPublish

// TODO: I can't imagine this will work in windows. Should probably fix that.
// TODO: less abomination, more DRY.


project.ext.PRERELEASE_ID = "prereleasetmp"
project.ext.SEMVER_PATTERN = ~"\\d+\\.\\d+\\.\\d+"

def msg = (project.hasProperty("message")) ? project.property("message") : "publish"

task preVersionCleanNpm(type: NpmTask) {
  args = ['run', 'clean']
}

def lernaVersionCommonCmd = [
  'node_modules/.bin/lerna', 'version',
  '--conventional-commits',
  '--exact',
  '--no-push',
  '--include-merged-tags',
  '--no-changelog'
]
task versionLevel1(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-prerelease=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills,react4xp',
    '--preid', "$project.ext.PRERELEASE_ID",
    '-m', "'chore(release lvl 1): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel2(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp-build-components,react4xp-runtime-client,react4xp-runtime-externals,react4xp-runtime-nashornpolyfills',
    '--preid', "$project.ext.PRERELEASE_ID",
    '-m', "'chore(release lvl 2): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}
task versionLevel3(type: Exec) {
  def cmds = lernaVersionCommonCmd + [
    '--conventional-graduate=react4xp',
    '--preid', "$project.ext.PRERELEASE_ID",
    '-m', "'chore(release lvl 3): $msg'"
  ]

  if (project.hasProperty("dry")) {
    cmds = ['echo', "\"${cmds.join(' ')}\""]
  }
  standardInput = System.in
  commandLine cmds
  doFirst {
    if (!project.hasProperty("dry")) println cmds.join(' ')
  }
}


////////////////////////

task cleanPrereleaseTags(type: Exec) {
  commandLine './cleanTagsContaining.sh', project.ext.PRERELEASE_ID
  enabled = !project.hasProperty("dry")
}


task gitAdd1(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
}
task gitAdd2(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
}
task gitAdd3(type: Exec) {
  commandLine 'git', 'add', '.', '--all'
  enabled = !project.hasProperty("dry")
}


task gitCommit1(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level1 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitCommit1.dependsOn gitAdd1

task gitCommit2(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level2 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitCommit2.dependsOn gitAdd2

task gitCommit3(type: Exec) {
  commandLine 'git', 'commit', "-m'Post level3 release: update package-locks'"
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitCommit3.dependsOn gitAdd3


task gitPush1(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitPush1.dependsOn gitCommit1

task gitPush2(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitPush2.dependsOn gitCommit2

task gitPush3(type: Exec) {
  commandLine 'git', 'push'
  enabled = !project.hasProperty("dry")
  ignoreExitValue true
}
gitPush3.dependsOn gitCommit3


task postLevel1() {}
postLevel1.dependsOn gitPush1

task postLevel2() {}
postLevel2.dependsOn gitPush2

task postLevel3() {}
postLevel3.dependsOn gitPush3


task versionAndPublish() {
  group('Publish')
  description('Automated full-project version bumping and NPM publishing of updated packages and their dependents. See versionAndPublish.gradle')
}


def getCurrentlyReleasedVersion(packageName, npmViewOutput, npmViewFailure, npmViewErrors, npmViewExitValue) {
  if (npmViewErrors) {
    if (npmViewOutput) {
      println "--- StdOut:"
      println npmViewOutput
      println "-"
    } else {
      println "--- (no StdOut)"
    }
    println "--- StdErr:"
    println "$npmViewErrors"
    println "-"
  }

  if (npmViewFailure || npmViewExitValue != 0) {
    println "--- exitValue: $npmViewExitValue"
    println "--- failure: $npmViewFailure"
    println "Command ('npm view $packageName version') produced stderr - aborting script."
    throw new GradleException("Command produced stderr: npm view $packageName version")
  }


  if (npmViewOutput ==~ project.ext.SEMVER_PATTERN) {
    return npmViewOutput
  }

  throw new GradleException("Unexpected output: non-semver string returned by NPM: '$npmViewOutput'")
}


def versionToNumber(verstionString) {
  def versionMatcher = verstionString =~ /(\d+)\.(\d+)\.(\d+)/
  if (!versionMatcher.matches()) {
    throw new GradleException("Version string '$verstionString' doesn't match the semver pattern 'major.minor.patch'")
  }
  def major = versionMatcher[0][1].toInteger()
  def minor = versionMatcher[0][2].toInteger()
  def patch = versionMatcher[0][3].toInteger()
  return major * 1000000 + minor * 1000 + patch
}


def shouldPublish(packageName, localVersion, npmViewOutput, npmViewResult, npmViewErrors) {
  if (localVersion ==~ project.ext.SEMVER_PATTERN) {
    def latestReleasedVersion = getCurrentlyReleasedVersion(packageName, npmViewOutput, npmViewResult.failure, npmViewErrors, npmViewResult.exitValue)
    if (!latestReleasedVersion) {
      return false
    }

    def latestReleaseValue = versionToNumber(latestReleasedVersion)
    def localValue = versionToNumber(localVersion)
    println "    Latest release: $latestReleasedVersion"
    println "    Local:          $localVersion"

    if (latestReleaseValue < localValue) {
      println "    Local version is ahead. Proceeding."
      return true

    } else if (latestReleaseValue == localValue) {
      println "    Local version is equal. Skipping."
      return false

    } else {
      throw new GradleException("Unexpected: local version '${localVersion}' is BEHIND latest release at NPM: '$latestReleasedVersion'. This automated script assumes local version is ahead, equal or temporary. Handle manually.")
    }

  } else {
    println "    Not publishing local ${packageName}@${localVersion}: version is not semver (major.minor.patch)."
    return false
  }
}


def getWaitMessage(currentLevel) {
  return "\n-----------------------------------\n\n" +
    "Package versions in level ${currentLevel} may have been updated. Before proceeding, ensure that packages aren't being committed and published with wrong interdependencies!\n\n" +
    "Here's how: check updated versions in level ${currentLevel} packages (see below). " +
    "Then, compare with <dependencies> in package.json in level ${currentLevel + 1} packages and verify that they match the updated versions from level ${currentLevel}. " +
    "If not, update dependencies manually, but ignore versions with '${project.ext.PRERELEASE_ID}'.\n\n" +
    "    - Level 1: The regions + constants packages are released FIRST, since other packages depend on them\n" +
    "    - Level 3 (THREE): The react4xp package is released LAST, since it depends on all the other packages\n" +
    "    - Level 2 (TWO): All other packages are published in between.\n\n" +
    "When you're ready, TYPE 'y' TO CONTINUE (git commit/push and npm publish).\n\n"
}

task wait1 {
  doLast {
    println getWaitMessage(1)
    def response = "";
    while (response != "y") {
      response = System.in.read()
      if (response != "y") {
        println "Type 'y' and Enter to continue"
      }
    }
  }
}
task wait2 {
  doLast {
    println getWaitMessage(2)
    def response = "";
    while (response != "y") {
      response = System.in.read()
      if (response != "y") {
        println "Type 'y' and Enter to continue"
      }
    }
  }
}

def NPM_PUBLISH_CMD = "npm publish${(!project.hasProperty("dry")) ? "" : ' --dry-run'}"

configure(subprojects.findAll { !project.ext.SUBPROJS_TO_IGNORE.contains(it.name) }) {
  // Set up 3 groups (levels) of publish, which must happen in that order.
  // Also disable publish for each package that has the prerelease ID in the version string:

  task npmClean1(type: Delete) {
    enabled = false
    delete 'node_modules'
  }
  task npmClean2(type: Delete) {
    enabled = false
    delete 'node_modules'
  }
  task npmClean3(type: Delete) {
    enabled = false
    delete 'node_modules'
  }
  npmClean3.dependsOn cleanPrereleaseTags


  task npmInstall1(type: NpmTask) {
    enabled = false
    args = ['install']
  }
  npmInstall1.dependsOn npmClean1

  task npmInstall2(type: NpmTask) {
    enabled = false
    args = ['install']
  }
  npmInstall2.dependsOn npmClean2

  task npmInstall3(type: NpmTask) {
    enabled = false
    args = ['install']
  }
  npmInstall3.dependsOn npmClean3


  task maybeSkipPublishLevel1 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 1: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      def stdout = new ByteArrayOutputStream()
      def stderr = new ByteArrayOutputStream()

      println "npm view ${PACKAGE_JSON.name} version"
      def result = exec {
        executable = 'npm'
        args = ['view', PACKAGE_JSON.name, 'version']
        standardOutput = stdout
        errorOutput = stderr
      }
      def output = stdout.toString().trim()
      def errors = stderr.toString().trim()

      if (!shouldPublish(PACKAGE_JSON.name, PACKAGE_JSON.version, output, result, errors)) {
        publishLevel1.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel1(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }

  task maybeSkipPublishLevel2 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 2: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      def stdout = new ByteArrayOutputStream()
      def stderr = new ByteArrayOutputStream()

      println "npm view ${PACKAGE_JSON.name} version"
      def result = exec {
        executable = 'npm'
        args = ['view', PACKAGE_JSON.name, 'version']
        standardOutput = stdout
        errorOutput = stderr
      }
      def output = stdout.toString().trim()
      def errors = stderr.toString().trim()

      if (!shouldPublish(PACKAGE_JSON.name, PACKAGE_JSON.version, output, result, errors)) {
        publishLevel2.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel2(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }

  task maybeSkipPublishLevel3 {
    enabled = false
    doLast {
      def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
      println "Level 3: $NPM_PUBLISH_CMD ${project.name}@${PACKAGE_JSON.version} ?"

      def stdout = new ByteArrayOutputStream()
      def stderr = new ByteArrayOutputStream()

      println "npm view ${PACKAGE_JSON.name} version"
      def result = exec {
        executable = 'npm'
        args = ['view', PACKAGE_JSON.name, 'version']
        standardOutput = stdout
        errorOutput = stderr
      }
      def output = stdout.toString().trim()
      def errors = stderr.toString().trim()

      if (!shouldPublish(PACKAGE_JSON.name, PACKAGE_JSON.version, output, result, errors)) {
        publishLevel3.configure {
          enabled = false
        }
      }
    }
  }
  task publishLevel3(type: Exec) {
    enabled = false

    commandLine = NPM_PUBLISH_CMD.split(" ")
  }


  // Enables/disables based on currently configured subproject's name:

  // regions and constants are released first, since other packages depend on them:
  if (project.name == "regions" || project.name == "constants") {
    publishLevel1.enabled = true
    maybeSkipPublishLevel1.enabled = true
    npmClean2.enabled = !project.hasProperty("dry")
    npmInstall2.enabled = !project.hasProperty("dry")
    npmClean1.enabled = !project.hasProperty("dry")
    npmInstall1.enabled = !project.hasProperty("dry")

    // react4xp is released last, since it depends on all the other packages:
  } else if (project.name == "react4xp") {
    publishLevel3.enabled = true
    maybeSkipPublishLevel3.enabled = true

    // All other packages are published in between:
  } else {
    publishLevel2.enabled = true
    maybeSkipPublishLevel2.enabled = true
    npmClean3.enabled = !project.hasProperty("dry")
    npmInstall3.enabled = !project.hasProperty("dry")
  }

  versionAndPublish.dependsOn postLevel3
  postLevel3.dependsOn publishLevel3
  publishLevel3.dependsOn maybeSkipPublishLevel3
  maybeSkipPublishLevel3.dependsOn versionLevel3

  versionLevel3.dependsOn postLevel2
  postLevel2.dependsOn publishLevel2
  publishLevel2.dependsOn maybeSkipPublishLevel2
  maybeSkipPublishLevel2.dependsOn versionLevel2

  versionLevel2.dependsOn postLevel1
  postLevel1.dependsOn publishLevel1
  publishLevel1.dependsOn maybeSkipPublishLevel1
  maybeSkipPublishLevel1.dependsOn versionLevel1
  versionLevel1.dependsOn preVersionCleanNpm

  gitAdd1.dependsOn npmInstall1
  gitAdd2.dependsOn npmInstall2
  gitAdd3.dependsOn npmInstall3

  cleanPrereleaseTags.dependsOn publishLevel3
  npmClean2.dependsOn wait2
  wait2.dependsOn publishLevel2
  npmClean1.dependsOn wait1
  wait1.dependsOn publishLevel1
}


///////////////////////////////////////////////////////////////////////////////
